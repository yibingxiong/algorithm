## 时间复杂度

一个算法流程中，常数操作数量的一个指标。常用O(读作big O)来表示.

写出这个算法流程中，发生了多少常数操作， 进而总结出常数操作数量的表达式。在表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果为f(N)，那么时间复杂度为O(f(N))。

## 空间复杂度

衡量程序额外占用内存空间的大小

## master公式

**T(N) = a*T(N/b) + O(N^d)**

1. log(b,a) > d -> 复杂度为O(N^log(b,a)) 
2. log(b,a) = d -> 复杂度为O(N^d * logN) 
3. log(b,a) < d -> 复杂度为O(N^d)

## 异或运算

1. 无进位相加
2. 0^N == N N^N == 0
3. 异或运算满足交换律和结合率

## 对数器

生成随机样本, 分别使用暴力算法和非暴力算法得到结果, 对比结果, 多次测试结果相同可认为两个算法实现正确.

## 排序

### 冒泡排序
1. 基本思路

两两比较, 如果前面的大于后边的则交换位置

2. 示例代码
```java
public static void bubbleSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    for (int i = arr.length - 1; i > 0; i--) {
        for (int j = 0; j < arr.length - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr, j, j + 1);
            }
        }
    }
}
```
### 选择排序
1. 基本思路
选择最小的数放到第一个位置, 选择次小的数放到第二个位置, 依次进行
2. 示例代码
```java
public static void selectionSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    for (int i = 0; i < arr.length - 1; i++) {
        int minV = arr[i];
        int minIndex = i;
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[j] < minV) {
                minV = arr[j];
                minIndex = j;
            }
        }
        swap(arr, i, minIndex);
    }
}
```
### 插入排序
1. 对每一个数, 依次和之前的数比较, 如果小, 则交换, 类似斗地主摸牌后插入手牌的过程.
2. 示例代码
```java
public static void inserSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    for (int i = 1; i < arr.length; i++) {
        int j = i;
        while (j > 0 && arr[j] < arr[j - 1]) {
            swap(arr, j, --j);
        }
    }
}
```
### 归并排序
1. 让左边有序, 右边有序然后合到一起, 关键在合的过程.
2. 示例代码
```java
public static void mergeSort(int[] arr, int left, int right) {
    if (left == right) {
        return;
    }
    int mid = left + ((right - left) / 2);
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, right, mid);
}

public static void mergeSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    mergeSort(arr, 0, arr.length - 1);
}

public static void merge(int[] arr, int left, int right, int mid) {
    int[] help = new int[right - left + 1];
    int p1 = left;
    int p2 = mid + 1;
    int i = 0;
    while (p1 <= mid && p2 <= right) {
        help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
    }
    while (p1 <= mid) {
        help[i++] = arr[p1++];
    }
    while (p2 <= right) {
        help[i++] = arr[p2++];
    }

    for (int k = 0; k < help.length; k++) {
        arr[left + k] = help[k];
    }
}
```
### 堆排序
1. 基本思路
通过heapyInsert构建大根堆, 依次将根和堆的最后一个元素交换, 然后从根调整堆.
1. 示例代码
```java
public static void heapSort(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
        heapInsert(arr, i);
    }

    for (int i = 0; i < arr.length; i++) {
        swap(arr, 0, arr.length - i - 1);
        heapyify(arr, 0, arr.length - i - 1);
    }
}

public static void heapInsert(int[] arr, int i) {
    while (arr[i] > arr[(i - 1) / 2]) {
        swap(arr, i, (i - 1) / 2);
        i = (i - 1) / 2;
    }
}

public static void heapyify(int[] arr, int i, int heapSize) {
    int left = 2 * i + 1; // 左孩子
    while (left < heapSize) {
        int larges = left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left;
        larges = arr[i] > arr[larges] ? i : larges;
        if (larges == i) { // 当前节点比两个孩子都大
            break;
        }
        swap(arr, i, larges);
        i = larges;
        left = 2 * i + 1;
    }
}
```
### 快速排序
1. 找一个位置的数, 将小于该数的数排左边, 大于等于的排右边(实质是将这个数放到了排序好的数组的正确位置), 对左边和右边的部分进行同样的操作.
2. 示例代码
```java
public static void quickSort(int[] arr) {
    if(arr == null || arr.length < 2) {
        return;
    }
    quickSort(arr, 0, arr.length-1);
}
public static void quickSort(int[] arr, int left, int right) {
    if (left < right) {
        swap(arr, left + (int) (Math.random() * (right - left + 1)), right);
        int p = partiton(arr, left, right);
        quickSort(arr, left, p-1);
        quickSort(arr, p+1, right);
    }
}

public static int partiton(int[] arr, int left, int right) {
    int less = left-1;
    while(left < right) {
        if(arr[left] < arr[right]) {
            swap(arr, ++less, left++);
        } else {
            left++;
        }
    }
    swap(arr, ++less, right);
    return less;
}
```
### 桶排序
与数据状况有关, 应用较少
### 排序小结
|排序算法|时间复杂度|空间复杂度|是否稳定|
|:---:|:----:|:---:|:--:|
|冒泡排序|O(n^2)|O(1)|是|
|选择排序|O(n^2)|O(1)|否|
|插入排序|O(n^2)|O(1)|是|
|归并排序|O(nlogn)|O(n)|是|
|快速排序|O(nlogn)|O(logn)|否|
|堆排序|O(nlogn)|O(1)|否|
|桶排序|-|-|是|

目前没有找到时间复杂度O(N*logN)，额外空间复杂度O(1)，又稳定的排序。